"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-simple-animate";
exports.ids = ["vendor-chunks/react-simple-animate"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-simple-animate/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-simple-animate/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nconst DEFAULT_DURATION = 0.3;\r\nconst DEFAULT_EASE_TYPE = 'linear';\r\nconst DEFAULT_DIRECTION = 'normal';\r\nconst DEFAULT_FILLMODE = 'none';\r\nconst RUNNING = 'running';\r\nconst PAUSED = 'paused';\r\nconst ALL = 'all';\n\nvar calculateTotalDuration = ({ duration = DEFAULT_DURATION, delay = 0, overlay = 0, }) => duration + delay - overlay || 0;\n\nvar isUndefined = (val) => val === undefined;\n\nfunction getSequenceId(sequenceIndex, sequenceId, defaultValue) {\r\n    if (isUndefined(sequenceId) && isUndefined(sequenceIndex)) {\r\n        return defaultValue || 0;\r\n    }\r\n    if (sequenceIndex && sequenceIndex >= 0) {\r\n        return sequenceIndex;\r\n    }\r\n    if (sequenceId) {\r\n        return sequenceId;\r\n    }\r\n    return 0;\r\n}\n\nconst AnimateContext = React__namespace.createContext({\r\n    animationStates: {},\r\n    register: () => { },\r\n});\r\nfunction AnimateGroup({ play, sequences = [], children, }) {\r\n    const [animationStates, setAnimationStates] = React__namespace.useState({});\r\n    const animationsRef = React__namespace.useRef({});\r\n    const register = React__namespace.useCallback((data) => {\r\n        const { sequenceIndex, sequenceId } = data;\r\n        if (!isUndefined(sequenceId) || !isUndefined(sequenceIndex)) {\r\n            animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data;\r\n        }\r\n    }, []);\r\n    React__namespace.useEffect(() => {\r\n        const sequencesToAnimate = Array.isArray(sequences) && sequences.length\r\n            ? sequences\r\n            : Object.values(animationsRef.current);\r\n        const localAnimationState = {};\r\n        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, { sequenceId, sequenceIndex, duration = DEFAULT_DURATION, delay, overlay, }, currentIndex) => {\r\n            const id = getSequenceId(sequenceIndex, sequenceId, currentIndex);\r\n            const currentTotalDuration = calculateTotalDuration({\r\n                duration,\r\n                delay,\r\n                overlay,\r\n            });\r\n            const totalDuration = currentTotalDuration + previous;\r\n            localAnimationState[id] = {\r\n                play,\r\n                pause: !play,\r\n                delay: (delay || 0) + previous,\r\n                controlled: true,\r\n            };\r\n            return totalDuration;\r\n        }, 0);\r\n        setAnimationStates(localAnimationState);\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [play]);\r\n    return (React__namespace.createElement(AnimateContext.Provider, { value: { animationStates, register } }, children));\r\n}\n\nvar secToMs = (ms) => (ms || 0) * 1000;\n\nfunction Animate(props) {\r\n    const { play, children, render, start, end, complete = '', onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, sequenceId, sequenceIndex, } = props;\r\n    const onCompleteTimeRef = React__namespace.useRef();\r\n    const [style, setStyle] = React__namespace.useState(start || {});\r\n    const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);\r\n    const id = getSequenceId(sequenceIndex, sequenceId);\r\n    React__namespace.useEffect(() => {\r\n        if ((!isUndefined(sequenceIndex) && sequenceIndex >= 0) || sequenceId) {\r\n            register(props);\r\n        }\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    React__namespace.useEffect(() => {\r\n        const animationState = animationStates[id] || {};\r\n        setStyle({\r\n            ...(play || animationState.play ? end : start),\r\n            transition: `${ALL} ${duration}s ${easeType} ${animationState.delay || delay}s`,\r\n        });\r\n        if (play && (complete || onComplete)) {\r\n            onCompleteTimeRef.current = setTimeout(() => {\r\n                complete && setStyle(complete);\r\n                onComplete && onComplete();\r\n            }, secToMs((animationState.delay || delay) + duration));\r\n        }\r\n        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);\r\n    }, [\r\n        id,\r\n        animationStates,\r\n        play,\r\n        duration,\r\n        easeType,\r\n        delay,\r\n        onComplete,\r\n        start,\r\n        end,\r\n        complete,\r\n    ]);\r\n    return render ? render({ style }) : React__namespace.createElement(\"div\", { style: style }, children);\r\n}\n\nvar camelCaseToDash = (camelCase) => camelCase ? camelCase.replace(/[A-Z]/g, c => `-${c.toLowerCase()}`) : '';\n\nconst generateKeyframes = (keyframes) => {\r\n    const animationLength = keyframes.length;\r\n    return keyframes.reduce((previous, keyframe, currentIndex) => {\r\n        const keyframePercentage = parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex;\r\n        if (typeof keyframe === 'string') {\r\n            return `${previous} ${keyframePercentage}% {${keyframe}}`;\r\n        }\r\n        const keys = Object.keys(keyframe);\r\n        if (keys.length && isNaN(+keys[0])) {\r\n            const keyframeContent = keys.reduce((acc, key) => `${acc} ${camelCaseToDash(key)}: ${keyframe[key]};`, '');\r\n            return `${previous} ${keyframePercentage}% {${keyframeContent}}`;\r\n        }\r\n        return `${previous} ${keys[0]}% {${keyframe[keys[0]]}}`;\r\n    }, '');\r\n};\r\nfunction createStyle({ keyframes, animationName, }) {\r\n    return `@keyframes ${animationName} {${generateKeyframes(keyframes)}}`;\r\n}\n\nfunction createTag({ keyframes, animationName, }) {\r\n    var _a, _b, _c, _d;\r\n    let styleTag = document.querySelector('style[data-id=rsi]');\r\n    if (!styleTag) {\r\n        styleTag = document.createElement('style');\r\n        styleTag.setAttribute('data-id', 'rsi');\r\n        document.head.appendChild(styleTag);\r\n    }\r\n    const index = (_c = (_b = (_a = styleTag.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\r\n    try {\r\n        (_d = styleTag.sheet) === null || _d === void 0 ? void 0 : _d.insertRule(createStyle({\r\n            keyframes,\r\n            animationName,\r\n        }), index);\r\n    }\r\n    catch (e) {\r\n        console.error('react simple animate, error found during insert style ', e); // eslint-disable-line no-console\r\n    }\r\n    return {\r\n        styleTag,\r\n        index,\r\n    };\r\n}\n\nvar deleteRules = (sheet, deleteName) => {\r\n    if (!sheet) {\r\n        return;\r\n    }\r\n    const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);\r\n    if (index >= 0) {\r\n        sheet.deleteRule(index);\r\n    }\r\n};\n\nvar createRandomName = () => `RSI-${Math.random()\r\n    .toString(36)\r\n    .substr(2, 9)}`;\n\nvar getPlayState = (pause) => (pause ? PAUSED : RUNNING);\n\nfunction AnimateKeyframes(props) {\r\n    const { children, play = false, pause = false, render, duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, sequenceIndex, keyframes, sequenceId, } = props;\r\n    let pauseValue;\r\n    const animationNameRef = React__namespace.useRef({\r\n        forward: '',\r\n        reverse: '',\r\n    });\r\n    const controlled = React__namespace.useRef(false);\r\n    const styleTagRef = React__namespace.useRef({\r\n        forward: null,\r\n        reverse: null,\r\n    });\r\n    const id = getSequenceId(sequenceIndex, sequenceId);\r\n    const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);\r\n    const animateState = animationStates[id] || {};\r\n    const [, forceUpdate] = React__namespace.useState(false);\r\n    React__namespace.useEffect(() => {\r\n        const styleTag = styleTagRef.current;\r\n        const animationName = animationNameRef.current;\r\n        animationNameRef.current.forward = createRandomName();\r\n        let result = createTag({\r\n            animationName: animationNameRef.current.forward,\r\n            keyframes,\r\n        });\r\n        styleTagRef.current.forward = result.styleTag;\r\n        animationNameRef.current.reverse = createRandomName();\r\n        result = createTag({\r\n            animationName: animationNameRef.current.reverse,\r\n            keyframes: keyframes.reverse(),\r\n        });\r\n        styleTagRef.current.reverse = result.styleTag;\r\n        register(props);\r\n        if (play) {\r\n            forceUpdate(true);\r\n        }\r\n        return () => {\r\n            var _a, _b;\r\n            deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);\r\n            deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    if (animateState.controlled && !controlled.current) {\r\n        pauseValue = animateState.pause;\r\n        if (!animateState.pause) {\r\n            controlled.current = true;\r\n        }\r\n    }\r\n    else {\r\n        pauseValue = pause;\r\n    }\r\n    const style = {\r\n        animation: `${duration}s ${easeType} ${animateState.delay || delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(pauseValue)} ${((animateState.controlled ? animateState.play : play)\r\n            ? animationNameRef.current.forward\r\n            : animationNameRef.current.reverse) || ''}`,\r\n    };\r\n    return render ? render({ style }) : React__namespace.createElement(\"div\", { style: style || {} }, children);\r\n}\n\nfunction useAnimate(props) {\r\n    const { start, end, complete, onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, } = props;\r\n    const transition = React__namespace.useMemo(() => `${ALL} ${duration}s ${easeType} ${delay}s`, [duration, easeType, delay]);\r\n    const [animate, setAnimate] = React__namespace.useState({\r\n        isPlaying: false,\r\n        style: { ...start, transition },\r\n    });\r\n    const { isPlaying, style } = animate;\r\n    const onCompleteTimeRef = React__namespace.useRef();\r\n    React__namespace.useEffect(() => {\r\n        if ((onComplete || complete) && isPlaying) {\r\n            onCompleteTimeRef.current = setTimeout(() => {\r\n                if (onComplete) {\r\n                    onComplete();\r\n                }\r\n                if (complete) {\r\n                    setAnimate((animate) => ({\r\n                        ...animate,\r\n                        style: complete,\r\n                    }));\r\n                }\r\n            }, secToMs(delay + duration));\r\n        }\r\n        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);\r\n    }, [animate, complete, delay, duration, isPlaying, onComplete]);\r\n    return {\r\n        isPlaying,\r\n        style,\r\n        play: React__namespace.useCallback((isPlaying) => {\r\n            setAnimate((animate) => ({\r\n                ...animate,\r\n                style: {\r\n                    ...(isPlaying ? end : start),\r\n                    transition,\r\n                },\r\n                isPlaying,\r\n            }));\r\n        }, [end, start, transition]),\r\n    };\r\n}\n\nfunction useAnimateKeyframes(props) {\r\n    const { duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, keyframes, } = props;\r\n    const animationNameRef = React__namespace.useRef({\r\n        forward: '',\r\n        reverse: '',\r\n    });\r\n    const styleTagRef = React__namespace.useRef({\r\n        forward: null,\r\n        reverse: null,\r\n    });\r\n    const { register } = React__namespace.useContext(AnimateContext);\r\n    const [isPlaying, setIsPlaying] = React__namespace.useState(null);\r\n    const [isPaused, setIsPaused] = React__namespace.useState(false);\r\n    React__namespace.useEffect(() => {\r\n        const styleTag = styleTagRef.current;\r\n        const animationName = animationNameRef.current;\r\n        animationNameRef.current.forward = createRandomName();\r\n        let result = createTag({\r\n            animationName: animationNameRef.current.forward,\r\n            keyframes,\r\n        });\r\n        styleTagRef.current.forward = result.styleTag;\r\n        animationNameRef.current.reverse = createRandomName();\r\n        result = createTag({\r\n            animationName: animationNameRef.current.reverse,\r\n            keyframes: keyframes.reverse(),\r\n        });\r\n        styleTagRef.current.reverse = result.styleTag;\r\n        register(props);\r\n        return () => {\r\n            var _a, _b;\r\n            deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);\r\n            deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    const style = {\r\n        animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(isPaused)} ${isPlaying === null\r\n            ? ''\r\n            : isPlaying\r\n                ? animationNameRef.current.forward\r\n                : animationNameRef.current.reverse}`,\r\n    };\r\n    return {\r\n        style,\r\n        play: setIsPlaying,\r\n        pause: setIsPaused,\r\n        isPlaying: !!isPlaying,\r\n    };\r\n}\n\nfunction createArrayWithNumbers(length) {\r\n    return Array.from({ length }, () => null);\r\n}\n\nfunction useAnimateGroup(props) {\r\n    const { sequences = [] } = props;\r\n    const defaultArray = createArrayWithNumbers(sequences.length).map((_, index) => props.sequences[index].start);\r\n    const [styles, setStyles] = React__namespace.useState(defaultArray);\r\n    const [isPlaying, setPlaying] = React__namespace.useState(false);\r\n    const animationNamesRef = React__namespace.useRef([]);\r\n    const styleTagRef = React__namespace.useRef([]);\r\n    React__namespace.useEffect(() => {\r\n        sequences.forEach(({ keyframes }, i) => {\r\n            if (!Array.isArray(keyframes)) {\r\n                return;\r\n            }\r\n            if (!animationNamesRef.current[i]) {\r\n                animationNamesRef.current[i] = {};\r\n                styleTagRef.current[i] = {};\r\n            }\r\n            animationNamesRef.current[i].forward = createRandomName();\r\n            let result = createTag({\r\n                animationName: animationNamesRef.current[i].forward,\r\n                keyframes,\r\n            });\r\n            styleTagRef.current[i].forward = result.styleTag;\r\n            animationNamesRef.current[i].reverse = createRandomName();\r\n            result = createTag({\r\n                animationName: animationNamesRef.current[i].reverse,\r\n                keyframes: keyframes.reverse(),\r\n            });\r\n            styleTagRef.current[i].reverse = result.styleTag;\r\n        });\r\n        const styleTags = styleTagRef.current;\r\n        const animationNames = animationNamesRef.current;\r\n        return () => Object.values(animationNames).forEach(({ forward, reverse }, i) => {\r\n            var _a, _b;\r\n            deleteRules((_a = styleTags[i].forward) === null || _a === void 0 ? void 0 : _a.sheet, forward);\r\n            deleteRules((_b = styleTags[i].reverse) === null || _b === void 0 ? void 0 : _b.sheet, reverse);\r\n        });\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    const play = React__namespace.useCallback((isPlay) => {\r\n        let totalDuration = 0;\r\n        const animationRefWithOrder = isPlay\r\n            ? animationNamesRef.current\r\n            : [...animationNamesRef.current].reverse();\r\n        const styles = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {\r\n            const { duration = DEFAULT_DURATION, delay = 0, overlay, keyframes, iterationCount = 1, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, end = {}, start = {}, } = current;\r\n            const delayDuration = currentIndex === 0 ? delay : totalDuration;\r\n            const transition = `${ALL} ${duration}s ${easeType} ${delayDuration}s`;\r\n            totalDuration =\r\n                calculateTotalDuration({ duration, delay, overlay }) + totalDuration;\r\n            return keyframes\r\n                ? {\r\n                    animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} ${RUNNING} ${isPlay\r\n                        ? animationRefWithOrder[currentIndex].forward\r\n                        : animationRefWithOrder[currentIndex].reverse}`,\r\n                }\r\n                : {\r\n                    ...(isPlay ? end : start),\r\n                    transition,\r\n                };\r\n        });\r\n        setStyles(isPlay ? styles : [...styles].reverse());\r\n        setPlaying(isPlay);\r\n    }, []);\r\n    return { styles, play, isPlaying };\r\n}\n\nexports.Animate = Animate;\nexports.AnimateGroup = AnimateGroup;\nexports.AnimateKeyframes = AnimateKeyframes;\nexports.useAnimate = useAnimate;\nexports.useAnimateGroup = useAnimateGroup;\nexports.useAnimateKeyframes = useAnimateKeyframes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWFuaW1hdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msc0RBQXNEOztBQUV0Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLENBQUM7QUFDRCx3QkFBd0IsaUNBQWlDO0FBQ3pELDhFQUE4RTtBQUM5RSxvREFBb0Q7QUFDcEQ7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RTtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxzRUFBc0UsU0FBUyw2QkFBNkI7QUFDNUc7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLGtLQUFrSztBQUM5SztBQUNBLG1FQUFtRTtBQUNuRSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSyxFQUFFLFNBQVMsSUFBSSxVQUFVLEVBQUUsOEJBQThCO0FBQ3pGLFNBQVM7QUFDVDtBQUNB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SDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDOztBQUVBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0xBQWtMLFlBQVksSUFBSTtBQUN0TjtBQUNBLGtDQUFrQyxLQUFLLEVBQUUsU0FBUyxJQUFJLFVBQVUsRUFBRSxjQUFjO0FBQ2hGO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVMsSUFBSSxVQUFVLEVBQUUsY0FBYyxJQUFJLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFO0FBQ25JO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7O0FBRUEsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QiwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXRpZW5jZV9hbGNoZW15Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXNpbXBsZS1hbmltYXRlL2Rpc3QvaW5kZXguanM/ZDQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcblxuY29uc3QgREVGQVVMVF9EVVJBVElPTiA9IDAuMztcclxuY29uc3QgREVGQVVMVF9FQVNFX1RZUEUgPSAnbGluZWFyJztcclxuY29uc3QgREVGQVVMVF9ESVJFQ1RJT04gPSAnbm9ybWFsJztcclxuY29uc3QgREVGQVVMVF9GSUxMTU9ERSA9ICdub25lJztcclxuY29uc3QgUlVOTklORyA9ICdydW5uaW5nJztcclxuY29uc3QgUEFVU0VEID0gJ3BhdXNlZCc7XHJcbmNvbnN0IEFMTCA9ICdhbGwnO1xuXG52YXIgY2FsY3VsYXRlVG90YWxEdXJhdGlvbiA9ICh7IGR1cmF0aW9uID0gREVGQVVMVF9EVVJBVElPTiwgZGVsYXkgPSAwLCBvdmVybGF5ID0gMCwgfSkgPT4gZHVyYXRpb24gKyBkZWxheSAtIG92ZXJsYXkgfHwgMDtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldFNlcXVlbmNlSWQoc2VxdWVuY2VJbmRleCwgc2VxdWVuY2VJZCwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBpZiAoaXNVbmRlZmluZWQoc2VxdWVuY2VJZCkgJiYgaXNVbmRlZmluZWQoc2VxdWVuY2VJbmRleCkpIHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlIHx8IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VxdWVuY2VJbmRleCAmJiBzZXF1ZW5jZUluZGV4ID49IDApIHtcclxuICAgICAgICByZXR1cm4gc2VxdWVuY2VJbmRleDtcclxuICAgIH1cclxuICAgIGlmIChzZXF1ZW5jZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlSWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxuXG5jb25zdCBBbmltYXRlQ29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dCh7XHJcbiAgICBhbmltYXRpb25TdGF0ZXM6IHt9LFxyXG4gICAgcmVnaXN0ZXI6ICgpID0+IHsgfSxcclxufSk7XHJcbmZ1bmN0aW9uIEFuaW1hdGVHcm91cCh7IHBsYXksIHNlcXVlbmNlcyA9IFtdLCBjaGlsZHJlbiwgfSkge1xyXG4gICAgY29uc3QgW2FuaW1hdGlvblN0YXRlcywgc2V0QW5pbWF0aW9uU3RhdGVzXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe30pO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uc1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IHJlZ2lzdGVyID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygoZGF0YSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgc2VxdWVuY2VJbmRleCwgc2VxdWVuY2VJZCB9ID0gZGF0YTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNlcXVlbmNlSWQpIHx8ICFpc1VuZGVmaW5lZChzZXF1ZW5jZUluZGV4KSkge1xyXG4gICAgICAgICAgICBhbmltYXRpb25zUmVmLmN1cnJlbnRbZ2V0U2VxdWVuY2VJZChzZXF1ZW5jZUluZGV4LCBzZXF1ZW5jZUlkKV0gPSBkYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBzZXF1ZW5jZXNUb0FuaW1hdGUgPSBBcnJheS5pc0FycmF5KHNlcXVlbmNlcykgJiYgc2VxdWVuY2VzLmxlbmd0aFxyXG4gICAgICAgICAgICA/IHNlcXVlbmNlc1xyXG4gICAgICAgICAgICA6IE9iamVjdC52YWx1ZXMoYW5pbWF0aW9uc1JlZi5jdXJyZW50KTtcclxuICAgICAgICBjb25zdCBsb2NhbEFuaW1hdGlvblN0YXRlID0ge307XHJcbiAgICAgICAgKHBsYXkgPyBzZXF1ZW5jZXNUb0FuaW1hdGUgOiBbLi4uc2VxdWVuY2VzVG9BbmltYXRlXS5yZXZlcnNlKCkpLnJlZHVjZSgocHJldmlvdXMsIHsgc2VxdWVuY2VJZCwgc2VxdWVuY2VJbmRleCwgZHVyYXRpb24gPSBERUZBVUxUX0RVUkFUSU9OLCBkZWxheSwgb3ZlcmxheSwgfSwgY3VycmVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ2V0U2VxdWVuY2VJZChzZXF1ZW5jZUluZGV4LCBzZXF1ZW5jZUlkLCBjdXJyZW50SW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VG90YWxEdXJhdGlvbiA9IGNhbGN1bGF0ZVRvdGFsRHVyYXRpb24oe1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBkZWxheSxcclxuICAgICAgICAgICAgICAgIG92ZXJsYXksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gY3VycmVudFRvdGFsRHVyYXRpb24gKyBwcmV2aW91cztcclxuICAgICAgICAgICAgbG9jYWxBbmltYXRpb25TdGF0ZVtpZF0gPSB7XHJcbiAgICAgICAgICAgICAgICBwbGF5LFxyXG4gICAgICAgICAgICAgICAgcGF1c2U6ICFwbGF5LFxyXG4gICAgICAgICAgICAgICAgZGVsYXk6IChkZWxheSB8fCAwKSArIHByZXZpb3VzLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsRHVyYXRpb247XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgc2V0QW5pbWF0aW9uU3RhdGVzKGxvY2FsQW5pbWF0aW9uU3RhdGUpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtwbGF5XSk7XHJcbiAgICByZXR1cm4gKFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChBbmltYXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBhbmltYXRpb25TdGF0ZXMsIHJlZ2lzdGVyIH0gfSwgY2hpbGRyZW4pKTtcclxufVxuXG52YXIgc2VjVG9NcyA9IChtcykgPT4gKG1zIHx8IDApICogMTAwMDtcblxuZnVuY3Rpb24gQW5pbWF0ZShwcm9wcykge1xyXG4gICAgY29uc3QgeyBwbGF5LCBjaGlsZHJlbiwgcmVuZGVyLCBzdGFydCwgZW5kLCBjb21wbGV0ZSA9ICcnLCBvbkNvbXBsZXRlLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gREVGQVVMVF9EVVJBVElPTiwgZWFzZVR5cGUgPSBERUZBVUxUX0VBU0VfVFlQRSwgc2VxdWVuY2VJZCwgc2VxdWVuY2VJbmRleCwgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qgb25Db21wbGV0ZVRpbWVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xyXG4gICAgY29uc3QgW3N0eWxlLCBzZXRTdHlsZV0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHN0YXJ0IHx8IHt9KTtcclxuICAgIGNvbnN0IHsgcmVnaXN0ZXIsIGFuaW1hdGlvblN0YXRlcyA9IHt9IH0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZUNvbnRleHQoQW5pbWF0ZUNvbnRleHQpO1xyXG4gICAgY29uc3QgaWQgPSBnZXRTZXF1ZW5jZUlkKHNlcXVlbmNlSW5kZXgsIHNlcXVlbmNlSWQpO1xyXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICgoIWlzVW5kZWZpbmVkKHNlcXVlbmNlSW5kZXgpICYmIHNlcXVlbmNlSW5kZXggPj0gMCkgfHwgc2VxdWVuY2VJZCkge1xyXG4gICAgICAgICAgICByZWdpc3Rlcihwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtdKTtcclxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBhbmltYXRpb25TdGF0ZSA9IGFuaW1hdGlvblN0YXRlc1tpZF0gfHwge307XHJcbiAgICAgICAgc2V0U3R5bGUoe1xyXG4gICAgICAgICAgICAuLi4ocGxheSB8fCBhbmltYXRpb25TdGF0ZS5wbGF5ID8gZW5kIDogc3RhcnQpLFxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgJHtBTEx9ICR7ZHVyYXRpb259cyAke2Vhc2VUeXBlfSAke2FuaW1hdGlvblN0YXRlLmRlbGF5IHx8IGRlbGF5fXNgLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwbGF5ICYmIChjb21wbGV0ZSB8fCBvbkNvbXBsZXRlKSkge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlVGltZVJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSAmJiBzZXRTdHlsZShjb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfSwgc2VjVG9NcygoYW5pbWF0aW9uU3RhdGUuZGVsYXkgfHwgZGVsYXkpICsgZHVyYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IG9uQ29tcGxldGVUaW1lUmVmLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KG9uQ29tcGxldGVUaW1lUmVmLmN1cnJlbnQpO1xyXG4gICAgfSwgW1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIGFuaW1hdGlvblN0YXRlcyxcclxuICAgICAgICBwbGF5LFxyXG4gICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgIGVhc2VUeXBlLFxyXG4gICAgICAgIGRlbGF5LFxyXG4gICAgICAgIG9uQ29tcGxldGUsXHJcbiAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgZW5kLFxyXG4gICAgICAgIGNvbXBsZXRlLFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gcmVuZGVyID8gcmVuZGVyKHsgc3R5bGUgfSkgOiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogc3R5bGUgfSwgY2hpbGRyZW4pO1xyXG59XG5cbnZhciBjYW1lbENhc2VUb0Rhc2ggPSAoY2FtZWxDYXNlKSA9PiBjYW1lbENhc2UgPyBjYW1lbENhc2UucmVwbGFjZSgvW0EtWl0vZywgYyA9PiBgLSR7Yy50b0xvd2VyQ2FzZSgpfWApIDogJyc7XG5cbmNvbnN0IGdlbmVyYXRlS2V5ZnJhbWVzID0gKGtleWZyYW1lcykgPT4ge1xyXG4gICAgY29uc3QgYW5pbWF0aW9uTGVuZ3RoID0ga2V5ZnJhbWVzLmxlbmd0aDtcclxuICAgIHJldHVybiBrZXlmcmFtZXMucmVkdWNlKChwcmV2aW91cywga2V5ZnJhbWUsIGN1cnJlbnRJbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleWZyYW1lUGVyY2VudGFnZSA9IHBhcnNlRmxvYXQoKDEwMCAvIChhbmltYXRpb25MZW5ndGggLSAxKSkudG9GaXhlZCgyKSkgKiBjdXJyZW50SW5kZXg7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlmcmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke3ByZXZpb3VzfSAke2tleWZyYW1lUGVyY2VudGFnZX0lIHske2tleWZyYW1lfX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoa2V5ZnJhbWUpO1xyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAmJiBpc05hTigra2V5c1swXSkpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWVDb250ZW50ID0ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBgJHthY2N9ICR7Y2FtZWxDYXNlVG9EYXNoKGtleSl9OiAke2tleWZyYW1lW2tleV19O2AsICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGAke3ByZXZpb3VzfSAke2tleWZyYW1lUGVyY2VudGFnZX0lIHske2tleWZyYW1lQ29udGVudH19YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGAke3ByZXZpb3VzfSAke2tleXNbMF19JSB7JHtrZXlmcmFtZVtrZXlzWzBdXX19YDtcclxuICAgIH0sICcnKTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlU3R5bGUoeyBrZXlmcmFtZXMsIGFuaW1hdGlvbk5hbWUsIH0pIHtcclxuICAgIHJldHVybiBgQGtleWZyYW1lcyAke2FuaW1hdGlvbk5hbWV9IHske2dlbmVyYXRlS2V5ZnJhbWVzKGtleWZyYW1lcyl9fWA7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFnKHsga2V5ZnJhbWVzLCBhbmltYXRpb25OYW1lLCB9KSB7XHJcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICBsZXQgc3R5bGVUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWlkPXJzaV0nKTtcclxuICAgIGlmICghc3R5bGVUYWcpIHtcclxuICAgICAgICBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ3JzaScpO1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXggPSAoX2MgPSAoX2IgPSAoX2EgPSBzdHlsZVRhZy5zaGVldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNzc1J1bGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAoX2QgPSBzdHlsZVRhZy5zaGVldCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluc2VydFJ1bGUoY3JlYXRlU3R5bGUoe1xyXG4gICAgICAgICAgICBrZXlmcmFtZXMsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgfSksIGluZGV4KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcigncmVhY3Qgc2ltcGxlIGFuaW1hdGUsIGVycm9yIGZvdW5kIGR1cmluZyBpbnNlcnQgc3R5bGUgJywgZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzdHlsZVRhZyxcclxuICAgICAgICBpbmRleCxcclxuICAgIH07XHJcbn1cblxudmFyIGRlbGV0ZVJ1bGVzID0gKHNoZWV0LCBkZWxldGVOYW1lKSA9PiB7XHJcbiAgICBpZiAoIXNoZWV0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXggPSBPYmplY3QudmFsdWVzKHNoZWV0LmNzc1J1bGVzKS5maW5kSW5kZXgoKHsgbmFtZSB9KSA9PiBuYW1lID09PSBkZWxldGVOYW1lKTtcclxuICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XHJcbiAgICB9XHJcbn07XG5cbnZhciBjcmVhdGVSYW5kb21OYW1lID0gKCkgPT4gYFJTSS0ke01hdGgucmFuZG9tKClcclxuICAgIC50b1N0cmluZygzNilcclxuICAgIC5zdWJzdHIoMiwgOSl9YDtcblxudmFyIGdldFBsYXlTdGF0ZSA9IChwYXVzZSkgPT4gKHBhdXNlID8gUEFVU0VEIDogUlVOTklORyk7XG5cbmZ1bmN0aW9uIEFuaW1hdGVLZXlmcmFtZXMocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIHBsYXkgPSBmYWxzZSwgcGF1c2UgPSBmYWxzZSwgcmVuZGVyLCBkdXJhdGlvbiA9IERFRkFVTFRfRFVSQVRJT04sIGRlbGF5ID0gMCwgZWFzZVR5cGUgPSBERUZBVUxUX0VBU0VfVFlQRSwgZGlyZWN0aW9uID0gREVGQVVMVF9ESVJFQ1RJT04sIGZpbGxNb2RlID0gREVGQVVMVF9GSUxMTU9ERSwgaXRlcmF0aW9uQ291bnQgPSAxLCBzZXF1ZW5jZUluZGV4LCBrZXlmcmFtZXMsIHNlcXVlbmNlSWQsIH0gPSBwcm9wcztcclxuICAgIGxldCBwYXVzZVZhbHVlO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uTmFtZVJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHtcclxuICAgICAgICBmb3J3YXJkOiAnJyxcclxuICAgICAgICByZXZlcnNlOiAnJyxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgY29udHJvbGxlZCA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IHN0eWxlVGFnUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe1xyXG4gICAgICAgIGZvcndhcmQ6IG51bGwsXHJcbiAgICAgICAgcmV2ZXJzZTogbnVsbCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaWQgPSBnZXRTZXF1ZW5jZUlkKHNlcXVlbmNlSW5kZXgsIHNlcXVlbmNlSWQpO1xyXG4gICAgY29uc3QgeyByZWdpc3RlciwgYW5pbWF0aW9uU3RhdGVzID0ge30gfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChBbmltYXRlQ29udGV4dCk7XHJcbiAgICBjb25zdCBhbmltYXRlU3RhdGUgPSBhbmltYXRpb25TdGF0ZXNbaWRdIHx8IHt9O1xyXG4gICAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBzdHlsZVRhZ1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LmZvcndhcmQgPSBjcmVhdGVSYW5kb21OYW1lKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGNyZWF0ZVRhZyh7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5mb3J3YXJkLFxyXG4gICAgICAgICAgICBrZXlmcmFtZXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3R5bGVUYWdSZWYuY3VycmVudC5mb3J3YXJkID0gcmVzdWx0LnN0eWxlVGFnO1xyXG4gICAgICAgIGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5yZXZlcnNlID0gY3JlYXRlUmFuZG9tTmFtZSgpO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVRhZyh7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5yZXZlcnNlLFxyXG4gICAgICAgICAgICBrZXlmcmFtZXM6IGtleWZyYW1lcy5yZXZlcnNlKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3R5bGVUYWdSZWYuY3VycmVudC5yZXZlcnNlID0gcmVzdWx0LnN0eWxlVGFnO1xyXG4gICAgICAgIHJlZ2lzdGVyKHByb3BzKTtcclxuICAgICAgICBpZiAocGxheSkge1xyXG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgZGVsZXRlUnVsZXMoKF9hID0gc3R5bGVUYWcuZm9yd2FyZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNoZWV0LCBhbmltYXRpb25OYW1lLmZvcndhcmQpO1xyXG4gICAgICAgICAgICBkZWxldGVSdWxlcygoX2IgPSBzdHlsZVRhZy5yZXZlcnNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hlZXQsIGFuaW1hdGlvbk5hbWUucmV2ZXJzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB9LCBbXSk7XHJcbiAgICBpZiAoYW5pbWF0ZVN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQuY3VycmVudCkge1xyXG4gICAgICAgIHBhdXNlVmFsdWUgPSBhbmltYXRlU3RhdGUucGF1c2U7XHJcbiAgICAgICAgaWYgKCFhbmltYXRlU3RhdGUucGF1c2UpIHtcclxuICAgICAgICAgICAgY29udHJvbGxlZC5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXVzZVZhbHVlID0gcGF1c2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHlsZSA9IHtcclxuICAgICAgICBhbmltYXRpb246IGAke2R1cmF0aW9ufXMgJHtlYXNlVHlwZX0gJHthbmltYXRlU3RhdGUuZGVsYXkgfHwgZGVsYXl9cyAke2l0ZXJhdGlvbkNvdW50fSAke2RpcmVjdGlvbn0gJHtmaWxsTW9kZX0gJHtnZXRQbGF5U3RhdGUocGF1c2VWYWx1ZSl9ICR7KChhbmltYXRlU3RhdGUuY29udHJvbGxlZCA/IGFuaW1hdGVTdGF0ZS5wbGF5IDogcGxheSlcclxuICAgICAgICAgICAgPyBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQuZm9yd2FyZFxyXG4gICAgICAgICAgICA6IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5yZXZlcnNlKSB8fCAnJ31gLFxyXG4gICAgfTtcclxuICAgIHJldHVybiByZW5kZXIgPyByZW5kZXIoeyBzdHlsZSB9KSA6IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiBzdHlsZSB8fCB7fSB9LCBjaGlsZHJlbik7XHJcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZShwcm9wcykge1xyXG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCBjb21wbGV0ZSwgb25Db21wbGV0ZSwgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IERFRkFVTFRfRFVSQVRJT04sIGVhc2VUeXBlID0gREVGQVVMVF9FQVNFX1RZUEUsIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gYCR7QUxMfSAke2R1cmF0aW9ufXMgJHtlYXNlVHlwZX0gJHtkZWxheX1zYCwgW2R1cmF0aW9uLCBlYXNlVHlwZSwgZGVsYXldKTtcclxuICAgIGNvbnN0IFthbmltYXRlLCBzZXRBbmltYXRlXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoe1xyXG4gICAgICAgIGlzUGxheWluZzogZmFsc2UsXHJcbiAgICAgICAgc3R5bGU6IHsgLi4uc3RhcnQsIHRyYW5zaXRpb24gfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgeyBpc1BsYXlpbmcsIHN0eWxlIH0gPSBhbmltYXRlO1xyXG4gICAgY29uc3Qgb25Db21wbGV0ZVRpbWVSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZigpO1xyXG4gICAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmICgob25Db21wbGV0ZSB8fCBjb21wbGV0ZSkgJiYgaXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVUaW1lUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0ZSgoYW5pbWF0ZSkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYW5pbWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGNvbXBsZXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgc2VjVG9NcyhkZWxheSArIGR1cmF0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiBvbkNvbXBsZXRlVGltZVJlZi5jdXJyZW50ICYmIGNsZWFyVGltZW91dChvbkNvbXBsZXRlVGltZVJlZi5jdXJyZW50KTtcclxuICAgIH0sIFthbmltYXRlLCBjb21wbGV0ZSwgZGVsYXksIGR1cmF0aW9uLCBpc1BsYXlpbmcsIG9uQ29tcGxldGVdKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNQbGF5aW5nLFxyXG4gICAgICAgIHN0eWxlLFxyXG4gICAgICAgIHBsYXk6IFJlYWN0X19uYW1lc3BhY2UudXNlQ2FsbGJhY2soKGlzUGxheWluZykgPT4ge1xyXG4gICAgICAgICAgICBzZXRBbmltYXRlKChhbmltYXRlKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgLi4uYW5pbWF0ZSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKGlzUGxheWluZyA/IGVuZCA6IHN0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGlzUGxheWluZyxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0sIFtlbmQsIHN0YXJ0LCB0cmFuc2l0aW9uXSksXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIHVzZUFuaW1hdGVLZXlmcmFtZXMocHJvcHMpIHtcclxuICAgIGNvbnN0IHsgZHVyYXRpb24gPSBERUZBVUxUX0RVUkFUSU9OLCBkZWxheSA9IDAsIGVhc2VUeXBlID0gREVGQVVMVF9FQVNFX1RZUEUsIGRpcmVjdGlvbiA9IERFRkFVTFRfRElSRUNUSU9OLCBmaWxsTW9kZSA9IERFRkFVTFRfRklMTE1PREUsIGl0ZXJhdGlvbkNvdW50ID0gMSwga2V5ZnJhbWVzLCB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBhbmltYXRpb25OYW1lUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoe1xyXG4gICAgICAgIGZvcndhcmQ6ICcnLFxyXG4gICAgICAgIHJldmVyc2U6ICcnLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBzdHlsZVRhZ1JlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKHtcclxuICAgICAgICBmb3J3YXJkOiBudWxsLFxyXG4gICAgICAgIHJldmVyc2U6IG51bGwsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IFJlYWN0X19uYW1lc3BhY2UudXNlQ29udGV4dChBbmltYXRlQ29udGV4dCk7XHJcbiAgICBjb25zdCBbaXNQbGF5aW5nLCBzZXRJc1BsYXlpbmddID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShudWxsKTtcclxuICAgIGNvbnN0IFtpc1BhdXNlZCwgc2V0SXNQYXVzZWRdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBzdHlsZVRhZ1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgYW5pbWF0aW9uTmFtZVJlZi5jdXJyZW50LmZvcndhcmQgPSBjcmVhdGVSYW5kb21OYW1lKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGNyZWF0ZVRhZyh7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5mb3J3YXJkLFxyXG4gICAgICAgICAgICBrZXlmcmFtZXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3R5bGVUYWdSZWYuY3VycmVudC5mb3J3YXJkID0gcmVzdWx0LnN0eWxlVGFnO1xyXG4gICAgICAgIGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5yZXZlcnNlID0gY3JlYXRlUmFuZG9tTmFtZSgpO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVRhZyh7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1hdGlvbk5hbWVSZWYuY3VycmVudC5yZXZlcnNlLFxyXG4gICAgICAgICAgICBrZXlmcmFtZXM6IGtleWZyYW1lcy5yZXZlcnNlKCksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3R5bGVUYWdSZWYuY3VycmVudC5yZXZlcnNlID0gcmVzdWx0LnN0eWxlVGFnO1xyXG4gICAgICAgIHJlZ2lzdGVyKHByb3BzKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICBkZWxldGVSdWxlcygoX2EgPSBzdHlsZVRhZy5mb3J3YXJkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hlZXQsIGFuaW1hdGlvbk5hbWUuZm9yd2FyZCk7XHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGVzKChfYiA9IHN0eWxlVGFnLnJldmVyc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGVldCwgYW5pbWF0aW9uTmFtZS5yZXZlcnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIH0sIFtdKTtcclxuICAgIGNvbnN0IHN0eWxlID0ge1xyXG4gICAgICAgIGFuaW1hdGlvbjogYCR7ZHVyYXRpb259cyAke2Vhc2VUeXBlfSAke2RlbGF5fXMgJHtpdGVyYXRpb25Db3VudH0gJHtkaXJlY3Rpb259ICR7ZmlsbE1vZGV9ICR7Z2V0UGxheVN0YXRlKGlzUGF1c2VkKX0gJHtpc1BsYXlpbmcgPT09IG51bGxcclxuICAgICAgICAgICAgPyAnJ1xyXG4gICAgICAgICAgICA6IGlzUGxheWluZ1xyXG4gICAgICAgICAgICAgICAgPyBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQuZm9yd2FyZFxyXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25OYW1lUmVmLmN1cnJlbnQucmV2ZXJzZX1gLFxyXG4gICAgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3R5bGUsXHJcbiAgICAgICAgcGxheTogc2V0SXNQbGF5aW5nLFxyXG4gICAgICAgIHBhdXNlOiBzZXRJc1BhdXNlZCxcclxuICAgICAgICBpc1BsYXlpbmc6ICEhaXNQbGF5aW5nLFxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheVdpdGhOdW1iZXJzKGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKCkgPT4gbnVsbCk7XHJcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZUdyb3VwKHByb3BzKSB7XHJcbiAgICBjb25zdCB7IHNlcXVlbmNlcyA9IFtdIH0gPSBwcm9wcztcclxuICAgIGNvbnN0IGRlZmF1bHRBcnJheSA9IGNyZWF0ZUFycmF5V2l0aE51bWJlcnMoc2VxdWVuY2VzLmxlbmd0aCkubWFwKChfLCBpbmRleCkgPT4gcHJvcHMuc2VxdWVuY2VzW2luZGV4XS5zdGFydCk7XHJcbiAgICBjb25zdCBbc3R5bGVzLCBzZXRTdHlsZXNdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZShkZWZhdWx0QXJyYXkpO1xyXG4gICAgY29uc3QgW2lzUGxheWluZywgc2V0UGxheWluZ10gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbk5hbWVzUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYoW10pO1xyXG4gICAgY29uc3Qgc3R5bGVUYWdSZWYgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihbXSk7XHJcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2VxdWVuY2VzLmZvckVhY2goKHsga2V5ZnJhbWVzIH0sIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleWZyYW1lcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnRbaV0pIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnRbaV0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHN0eWxlVGFnUmVmLmN1cnJlbnRbaV0gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lc1JlZi5jdXJyZW50W2ldLmZvcndhcmQgPSBjcmVhdGVSYW5kb21OYW1lKCk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjcmVhdGVUYWcoe1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uTmFtZTogYW5pbWF0aW9uTmFtZXNSZWYuY3VycmVudFtpXS5mb3J3YXJkLFxyXG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3R5bGVUYWdSZWYuY3VycmVudFtpXS5mb3J3YXJkID0gcmVzdWx0LnN0eWxlVGFnO1xyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lc1JlZi5jdXJyZW50W2ldLnJldmVyc2UgPSBjcmVhdGVSYW5kb21OYW1lKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVRhZyh7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25OYW1lOiBhbmltYXRpb25OYW1lc1JlZi5jdXJyZW50W2ldLnJldmVyc2UsXHJcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXM6IGtleWZyYW1lcy5yZXZlcnNlKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdHlsZVRhZ1JlZi5jdXJyZW50W2ldLnJldmVyc2UgPSByZXN1bHQuc3R5bGVUYWc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3Qgc3R5bGVUYWdzID0gc3R5bGVUYWdSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBhbmltYXRpb25OYW1lcyA9IGFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IE9iamVjdC52YWx1ZXMoYW5pbWF0aW9uTmFtZXMpLmZvckVhY2goKHsgZm9yd2FyZCwgcmV2ZXJzZSB9LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGVzKChfYSA9IHN0eWxlVGFnc1tpXS5mb3J3YXJkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hlZXQsIGZvcndhcmQpO1xyXG4gICAgICAgICAgICBkZWxldGVSdWxlcygoX2IgPSBzdHlsZVRhZ3NbaV0ucmV2ZXJzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoZWV0LCByZXZlcnNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBwbGF5ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygoaXNQbGF5KSA9PiB7XHJcbiAgICAgICAgbGV0IHRvdGFsRHVyYXRpb24gPSAwO1xyXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblJlZldpdGhPcmRlciA9IGlzUGxheVxyXG4gICAgICAgICAgICA/IGFuaW1hdGlvbk5hbWVzUmVmLmN1cnJlbnRcclxuICAgICAgICAgICAgOiBbLi4uYW5pbWF0aW9uTmFtZXNSZWYuY3VycmVudF0ucmV2ZXJzZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IChpc1BsYXkgPyBzZXF1ZW5jZXMgOiBbLi4uc2VxdWVuY2VzXS5yZXZlcnNlKCkpLm1hcCgoY3VycmVudCwgY3VycmVudEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZHVyYXRpb24gPSBERUZBVUxUX0RVUkFUSU9OLCBkZWxheSA9IDAsIG92ZXJsYXksIGtleWZyYW1lcywgaXRlcmF0aW9uQ291bnQgPSAxLCBlYXNlVHlwZSA9IERFRkFVTFRfRUFTRV9UWVBFLCBkaXJlY3Rpb24gPSBERUZBVUxUX0RJUkVDVElPTiwgZmlsbE1vZGUgPSBERUZBVUxUX0ZJTExNT0RFLCBlbmQgPSB7fSwgc3RhcnQgPSB7fSwgfSA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RHVyYXRpb24gPSBjdXJyZW50SW5kZXggPT09IDAgPyBkZWxheSA6IHRvdGFsRHVyYXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSBgJHtBTEx9ICR7ZHVyYXRpb259cyAke2Vhc2VUeXBlfSAke2RlbGF5RHVyYXRpb259c2A7XHJcbiAgICAgICAgICAgIHRvdGFsRHVyYXRpb24gPVxyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlVG90YWxEdXJhdGlvbih7IGR1cmF0aW9uLCBkZWxheSwgb3ZlcmxheSB9KSArIHRvdGFsRHVyYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlmcmFtZXNcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYCR7ZHVyYXRpb259cyAke2Vhc2VUeXBlfSAke2RlbGF5RHVyYXRpb259cyAke2l0ZXJhdGlvbkNvdW50fSAke2RpcmVjdGlvbn0gJHtmaWxsTW9kZX0gJHtSVU5OSU5HfSAke2lzUGxheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFuaW1hdGlvblJlZldpdGhPcmRlcltjdXJyZW50SW5kZXhdLmZvcndhcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhbmltYXRpb25SZWZXaXRoT3JkZXJbY3VycmVudEluZGV4XS5yZXZlcnNlfWAsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi4oaXNQbGF5ID8gZW5kIDogc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNldFN0eWxlcyhpc1BsYXkgPyBzdHlsZXMgOiBbLi4uc3R5bGVzXS5yZXZlcnNlKCkpO1xyXG4gICAgICAgIHNldFBsYXlpbmcoaXNQbGF5KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHJldHVybiB7IHN0eWxlcywgcGxheSwgaXNQbGF5aW5nIH07XHJcbn1cblxuZXhwb3J0cy5BbmltYXRlID0gQW5pbWF0ZTtcbmV4cG9ydHMuQW5pbWF0ZUdyb3VwID0gQW5pbWF0ZUdyb3VwO1xuZXhwb3J0cy5BbmltYXRlS2V5ZnJhbWVzID0gQW5pbWF0ZUtleWZyYW1lcztcbmV4cG9ydHMudXNlQW5pbWF0ZSA9IHVzZUFuaW1hdGU7XG5leHBvcnRzLnVzZUFuaW1hdGVHcm91cCA9IHVzZUFuaW1hdGVHcm91cDtcbmV4cG9ydHMudXNlQW5pbWF0ZUtleWZyYW1lcyA9IHVzZUFuaW1hdGVLZXlmcmFtZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-simple-animate/dist/index.js\n");

/***/ })

};
;